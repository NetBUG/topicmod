package lda.external;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

import lib_corpora_proto.ProtoCorpus.Corpus;
import lib_corpora_proto.ProtoCorpus.Document;
import utils.Constants;
import utils.DataSet;
import utils.LDAState;
import utils.PropertiesGetter;
import utils.files.SessionFileUtils;

/**
 * This class is responsible for calling all of the external LDA commands.
 * This includes both the topic updating command (resume_topics_update.py)
 * and the LDA itself (ldawn). The method to retrieve the result from the
 * protocol buffer is also here.
 */
public class LDACaller
{
	/**
	 * The results generated by the LDA command, in protocol buffer
	 * object form.
	 */
	public static class Result
	{
		public Corpus corpus;
		public List<Document> documents;
	}

	/**
	 * This is the top-level method for calling the LDA commands.
	 */
	public static void callLDA(LDAState theState, int numIterations)
	{
		DataSet dataSet = theState.dataSet;
		int numTopics = theState.numTopics;
		int numConstraints = theState.constraints.size();
		int randomSeed = theState.randomSeed;
		boolean append = theState.append;
		
		PropertiesGetter props = new PropertiesGetter();
		
		if (!append)
		{
			// Delete the progress file (model.lhood) if we're starting over.
			SessionFileUtils.removeProgressFile(theState);
		}

		try
		{
			// Create a backup of the progress file, if one exists.
			SessionFileUtils.copyProgressFile(theState);
			
			// If no random seed has been specified in the state, use
			// the default one.
			int randomSeedToUse = randomSeed;
			if (randomSeedToUse < 0)
			{
				randomSeedToUse = Constants.DEFAULT_RANDOM_SEED;
			}
			
			// create the environment variables
			String[] envs = new String[2];
			envs[0] = "LD_LIBRARY_PATH=" + props.getLibraryPath();
			envs[1] = "PYTHONPATH=" + props.getPythonPath();

			// Call the topic updating command if we're appending iterations
			// to an existing LDA state.
			if (append)
			{
				String preCommand = getPreCommand(theState, dataSet, numTopics, numIterations,
						numConstraints, randomSeedToUse, append);
				Process p = Runtime.getRuntime().exec(preCommand, envs);
				waitForProcess(p);
			}
			
			// Now run the LDA itself!
			String command = getCommand(theState, dataSet, numTopics, numIterations,
					numConstraints, randomSeedToUse, append);
			theState.lastCommand = command;
			System.out.println(command + "\n");

			Process p = Runtime.getRuntime().exec(command, envs);

			// Do NOT wait for LDA to finish
			// waitForProcess(p);

		} catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	
	/**
	 * Waits for a process to finish.
	 */
	private static void waitForProcess(Process p) throws Exception
	{
		System.out.println("Getting error stream\n");
		InputStream stream = p.getInputStream();
		int x = 0;
		while ((x = stream.read()) >= 0)
			; // System.out.print((char)x);

		System.out.println("Getting output stream\n");
		stream = p.getInputStream();
		while ((x = stream.read()) >= 0)
			; // System.out.print((char)x); // read until done

		System.out.println("Calling waitFor\n");
		int result = p.waitFor();
		System.out.println("Result was: " + result + "\n");
	}

	/**
	 * Forms the full command that will be used to call LDA.
	 */
	public static String getCommand(LDAState theState, DataSet dataSet, int numTopics,
			int numIterations, int numConstraints, int randomSeed,
			boolean append)
	{
		File file = new File(dataSet.protocolFilename);
		String vocabFile = dataSet.vocabFilename;
		String constraintFile = SessionFileUtils.getConstraintFile(theState) + ".0";
		
		String corpusLoc = "", indexName = "";
		if (dataSet.useAbsolutePath)
		{
			corpusLoc = "/";
			indexName = file.getAbsolutePath();
		}
		else
		{
			corpusLoc = file.getParent();
			indexName = file.getName();
		}
		
		int realTopics = numTopics + Constants.JUNK_TOPICS;

		String command =  new PropertiesGetter().getLdaCommand() + " " + " --corpus_location="
				+ corpusLoc + " --num_topics=" + realTopics + " --vocab_file="
				+ vocabFile + " --train_section=" + indexName
				+ " --output_location="
				+ SessionFileUtils.getCommandOutputDir(theState) + " --num_iterations="
				+ numIterations + " --wordnet_location=" + constraintFile
				+ " --rand=" + randomSeed;

		if (append)
		{
			command = command + " --resume=true";
		}
		if (numConstraints > 0)
		{
			command = command + " --debug_synsets=" + getConstraintStr(numConstraints);
		}

		return command;
	}
	
	/**
	 * Forms the full command that will be used to call the topic updater.
	 */
	private static String getPreCommand(LDAState theState, DataSet dataSet, int numTopics,
			int numIterations, int numConstraints, int randomSeed,
			boolean append)
	{
		File file = new File(dataSet.protocolFilename);
		String parentDir = file.getParentFile().getParent();
		String constraintFile = SessionFileUtils.getConstraintFile(theState) + ".0";
		
		String preCommand = new PropertiesGetter().getUpdateCommand() +
		" --ldawnoutput=" + parentDir + 
		" --maps=" + parentDir +
		" --wordnet=" + constraintFile + ";";
		return preCommand;
	}
	
	/**
	 * Put the indexes of all the constraints in string form, to be used with
	 * the "debug_synsets" option. 
	 * 
	 * TODO: does this need to be changed with cannot-link constraints?
	 */
	private static String getConstraintStr(int numConstraints)
	{
		String str = "";
		for (int i = 0; i < numConstraints; i++)
			str += "," + (i+1);
		return str.substring(1);
	}

	/**
	 * Gets the LDA result in protocol buffer object form.
	 */
	public static Result getResult(String directory, String indexFile)
	{
		Result result = new Result();
		result.documents = new ArrayList<Document>();
		try
		{
			String filename = directory + "/" + indexFile;
			FileInputStream fis = new FileInputStream(filename);
			result.corpus = Corpus.parseFrom(fis);
			fis.close();
			for (String docFile : result.corpus.getDocFilenamesList())
			{
				fis = new FileInputStream(directory + "/" + docFile);
				Document doc = Document.parseFrom(fis);
				fis.close();
				result.documents.add(doc);
			}

		} catch (Exception e)
		{
			e.printStackTrace();
		}
		return result;
	}

	/**
	 * Returns the number of lines in a file, or 0 if the file does not exist.
	 */
	public static int getLines(String filename)
	{
		try
		{
			// if the file wasn't created yet, just return 0 lines
			File file = new File(filename);
			if (!file.exists())
			{
				return 0;
			}

			BufferedReader reader = new BufferedReader(new FileReader(filename));
			int numLines = 0;
			while (reader.readLine() != null)
				numLines++;
			reader.close();
			return numLines;
			
		} catch (Exception e)
		{
			e.printStackTrace();
			return -1;
		}

	}

}
